//ЗАДАЧИ НА 3 СЕМЕСТР\\

#define CATCH_CONFIG_MAIN
#include "catch2\catch.hpp"

/*
Задача 1.
tags: C++, сложность D, семестр 3, STL, stack
Дана строка вида (){}[]{}{})(){)))
Необходимо проверить, что:
1. Для каждой открывающей скобки есть соответственная закрывающая;
2. Не возникает ситуаций вида ( { ) } — скобки закрываются "не там".
Если условия не выполнены, вывести, по какому индексу в строке произошла ошибка.
Реализовать с помощью std::stack.
Напишите функцию balance, которая проверяет выполнение баланса скобок. 
Функция принимает строку, возращает std::pair<int, int>. 
Если баланс выполняется,  на первое место записывается 1, на второе -1. 
Если не выполняется, на первое записывается 0, на второе - индекс, где произошла ошибка.
Примечание: в строке могут быть другие символы.
Example 1:
input: 
(){}([])
output:
1 -1
Example 2:
input: 
([{aaa})]
output:
0 7
*/

std::pair<int,int> balance(std::string str);
TEST_CASE("Balance") 
{
    SECTION("ex1") {
        std::pair<int,int> test(1,-1);
        std::pair<int,int> res = balance("(){}([])");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex2") {
        std::pair<int,int> test(0,7);
        std::pair<int,int> res = balance("([{aaa})]");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex3") {
        std::pair<int,int> test(1,-1);
        std::pair<int,int> res = balance("{()[][()]}");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex4") {
        std::pair<int,int> test(0,4);
        std::pair<int,int> res = balance("([])(");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex5") {
        std::pair<int,int> test(0,0);
        std::pair<int,int> res = balance(")([]");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex6") {
        std::pair<int,int> test(0,0);
        std::pair<int,int> res = balance(")");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex7") {
        std::pair<int,int> test(0,0);
        std::pair<int,int> res = balance("{");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex8") {
        std::pair<int,int> test(1,-1);
        std::pair<int,int> res = balance("()");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex9") {
        std::pair<int,int> test(1,-1);
        std::pair<int,int> res = balance("");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
    SECTION("ex10") {
        std::pair<int,int> test(0,6);
        std::pair<int,int> res = balance("()([[])]");
        REQUIRE(test.first == res.first);
        REQUIRE(test.second == res.second);
    }
}


/*
Задача 2.
tags: C++, сложность D, семестр 3, STL, работа с файлами
В функцию numberOfSequences подаются две строки - названия входного и выходного файла.
В единственной строке входного файла находится последовательность, 
содержащая произвольную комбинацию 0 и 1, разделенных пробелом.
Записать во второй файл (выходной) два числа - количество последовательностей из 1 и 0. 
Примечание: использовать unique(), count().
Примечание 2: данные в выходном файле перезаписываются. 
Example 1:
input: 
1 0 1 1
output:
2 1
Example 2:
input: 
0 0 0 
output:
0 1
*/

void numberOfSequences(std::string input, std::string output);
TEST_CASE("") 
{
    SECTION("1") {
        //input.txt 1 0 1 1
        numberOfSequences("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 2);
        file >> n;
        REQUIRE(n == 1);
        file.close();
    }
    SECTION("2") {
        //input.txt 0 0 0
        numberOfSequences("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 0);
        file >> n;
        REQUIRE(n == 1);
        file.close();
    }
    SECTION("3") {
        //input.txt 1 0 1 1 0 0 1
        numberOfSequences("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 3);
        file >> n;
        REQUIRE(n == 2);
        file.close();
    }
    SECTION("4") {
        //input.txt 0 1 0 1 0
        numberOfSequences("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 2);
        file >> n;
        REQUIRE(n == 3);
        file.close();
    }
    SECTION("5") {
        //input.txt 1 1
        numberOfSequences("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 1);
        file >> n;
        REQUIRE(n == 0);
        file.close();
    }
    SECTION("6") {
        //input.txt (empty)
        numberOfSequences("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 0);
        file >> n;
        REQUIRE(n == 0);
        file.close();
    }
}


/*
Задача 3.
tags: C++, сложность D, семестр 3, STL, работа с файлами
В функцию playingCards подаются две строки - названия входного и выходного файла.
Первая строка входного файла содержит одно четное натуральное число N. 
Вторая строка входного файла содержит ровно N чисел - числа, написанные на игральных карточках. 
Все числа в строке разделяются одиночными пробелами. Игроки выбирают закрытые карточки, 
первый выбирает половину карточек, второй забирает оставшуюся половину. 
Во второй файл записать максимальный выигрыш, который можно получить, т.е разница между суммами чисел на карточках. 
Примечание: используйте sort()/partial_sort(), reverve(), accumulate(), std::greater
Example 1:
input: 
2
1 3
output:
2
Example 2:
input: 
4
3 1 8 100  
output:
104
*/

void playingCards(std::string input, std::string output);
TEST_CASE("playing Cards") 
{
    SECTION("1") {
        //input.txt 
        //2
        //1 3
        playingCards("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 2);
        file.close();
    }
    SECTION("2") {
        //input.txt 
        //4
        //3 1 8 100
        playingCards("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 104);
        file.close();
    }
    SECTION("3") {
        //input.txt 
        //6
        //5 10 8 9 19 14
        playingCards("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 21);
        file.close();
    }
    SECTION("4") {
        //input.txt 
        //4
        //2 2 2 2
        playingCards("input.txt", "output.txt");
        int n;
        std::ifstream file("output.txt");
        file >> n;
        REQUIRE(n == 0);
        file.close();
    }
}


/*
Задача 4.
tags: C++, сложность D, семестр 3, STL, вектор
Напишите функцию deleteElement, которая исключит из вектора первый четный элемент, следующий за максимальным. 
На вход подается вектор целых чисел. 
На выход - напечатать позицию элемента и его значение, вернуть массив после удаления элемента. 
Примечание: resize(), copy() и ofstream_iterator (для вывода вектора), max_element(), 
find_if с лямбда-функцией для определение четности число ([](тип значение) {код}), distance(), erase().
*/

std::vector<int> deleteElement(std::vector<int> input);
TEST_CASE(" ")
{
    SECTION("1") {
        std::vector<int> input = {1, 5, 6, 8, -1, 4};
        std::vector<int> res = {1, 5, 6, 8, -1};
        std::vector<int> test = deleteElement(input);
        for (int i = 0; i < res.size(); i++) {
            REQUIRE(res[i] == test[i]);
        }
    }
    SECTION("2") {
        std::vector<int> input = {8, 1, 2, 3};
        std::vector<int> res = {8, 1, 3};
        std::vector<int> test = deleteElement(input);
        for (int i = 0; i < res.size(); i++) {
            REQUIRE(res[i] == test[i]);
        }
    }
    SECTION("4") {
        std::vector<int> input = {1, 2, 3, 4};
        std::vector<int> res = {1, 2, 3, 4};
        std::vector<int> test = deleteElement(input);
        for (int i = 0; i < res.size(); i++) {
            REQUIRE(res[i] == test[i]);
        }
    }
    SECTION("5") {
        std::vector<int> input = {1, 4, 3, -1};
        std::vector<int> res = {1, 4, 3, -1};
        std::vector<int> test = deleteElement(input);
        for (int i = 0; i < res.size(); i++) {
            REQUIRE(res[i] == test[i]);
        }
    }
}


/*
Задача 5.
tags: C++, сложность E, семестр 3
Напишите функцию sumNumber, которая принимает две строки - числа в разных системах счисления (со 2 по 36)
и выводит их сумму в двоичной системе счисления. Числа представлены в виде: число_системаСчисления
Example:
input: 10011_2 171_8
output: 10001100
*/

std::string sumNumber(std::string first, std::string second);
TEST_CASE("Sum two number") 
{
    REQUIRE(sumNumber("10011_2", "171_8") == std::string("10001100"));
    REQUIRE(sumNumber("1011_2", "8A5_16") == std::string("100010110000"));
    REQUIRE(sumNumber("FF_16", "HELLO_36") == std::string("1101111100001011011011011"));
    REQUIRE(sumNumber("120802_10", "171765_8") == std::string("101100101111010111"));
    REQUIRE(sumNumber("851_10", "123_10") == std::string("11 1100 1110"));
}


/*
Задача 6.
tags: C++, сложность D, семестр 3, STL, работа с файлами
Даны 12 csv-файлов с логинами и их зашифрованными через радуждные таблицы версиями. 
Пользователь вводит зашифрованный логин, необходимо найти в файлах его оригинал.
*/


/*
Задача 7.
tags: C++, сложность C, семестр 3, ООП
Разработать шаблонный класс Pair, хранящий пару значений разных типов. Класс должен:
● реализовывать методы для доступа к значениям и задания значений;
● реализовывать операторы сравнения (==, !=);
● реализовывать оператор сложения, складывающий соответствующие элементы пары;
● реализовывать оператор выставки в поток (<<), выводящий в консоль пару в виде “(first, second)”; 
● реализовать оператор извлечения из потока (>>), принимающий два значения из консоли и заполняющий ими пару строк;
● метод, принимающий два значения и возвращающий составленную из них пару;
● метод, принимающий пару и возвращающий пару, в которой первое значение поставлено
  на место второго, второе – на место первого 
*/

/*
Задача 8.
tags: C++, сложность D, семестр 3, работа с файлами
Написать программу, которая построчно объединяет файлы, переданные ей как аргументы командной строки, 
и выводит их в новый текстовый файл.
Передачу имен файлов реализовать через аргументы командной строки.
Объединение происходит таким образом, что сначала выводятся первые строки всех файлов по 
порядку следования, потом вторые, третьи и т. д.
Если какие-то из файлов не могут быть найдены или открыты, программа должна выдать 
предупреждение об этом в стандартный вывод ошибок (cerr) и продолжить работу, игнорируя неоткрытые файлы.
Example:
input:
Файл 1.txt:
aa
bb
cc

Файл 2.txt:
0
1

Файл 3.txt:
hey

output:
aa
0
hey
bb
1
cc
*/

/*
Задача 9.
tags: C++, сложность D, семестр 3, STL
Дано N чисел, требуется выяснить, сколько среди них различных.
В первой строке дано число N – количество чисел. (1 <= N <= 100000) 
Во второй строке даны через пробел N чисел, каждое не превышает 2*10^9 по модулю.
Выведите число, равное количеству различных чисел среди данных.
Примечание: использовать STL.
Example:
input:
5
1 0 1 2 0
output:
3
*/

/*
Задача 10.
tags: C++, сложность D, семестр 3, STL
Напишите программу, которая моделирует игру в пьяницу и определяет, кто выигрывает. 
В игре участвует 10 карт, имеющих значения от 0 до 9, большая карта побеждает меньшую, карта со значением 0 побеждает карту 9.
Программа получает на вход две строки: первая строка содержит 5 чисел, разделенных пробелами — номера карт первого игрока, 
вторая – аналогично 5 карт второго игрока. Карты перечислены сверху вниз, то есть каждая строка начинается с той карты, которая будет открыта первой.
Программа должна определить, кто выигрывает при данной раздаче, и вывести слово first или second, после чего вывести количество ходов, 
сделанных до выигрыша. Если на протяжении 10^6 ходов игра не заканчивается, программа должна вывести слово botva.
Примечание: использовать STL.
Example:
input:
1 3 5 7 9
2 4 6 8 0
output:
second 5
*/


/*
Задача 11.
tags: C++, сложность C, семестр 3, STL, stack
На складе хранятся контейнеры с товарами N различных видов. Все контейнеры составлены в N стопок. 
В каждой стопке могут находиться контейнеры с товарами любых видов (стопка может быть изначально пустой).
Автопогрузчик может взять верхний контейнер из любой стопки и поставить его сверху в любую стопку. 
Необходимо расставить все контейнеры с товаром первого вида в первую стопку, второго вида – во вторую стопку и т.д.
Программа должна вывести последовательность действий автопогрузчика или сообщение о том, что задача решения не имеет.
В первой строке входных данных записано одно натуральное число N, не превосходящее 500. 
В следующих N строках описаны стопки контейнеров: сначала записано число ki – количество контейнеров в стопке, 
а затем ki чисел – виды товара в контейнерах в данной стопке, снизу вверх. В каждой стопке вначале 
не более 500 контейнеров (в процессе переноса контейнеров это ограничение может быть нарушено).
Программа должна вывести описание действий автопогрузчика: для каждого действия напечатать два 
числа – из какой стопки брать контейнер и в какую стопку класть. (Обратите внимание, что минимизировать 
количество операций автопогрузчика не требуется.) Если задача не имеет решения, необходимо вывести одно число 0. 
Если контейнеры изначально правильно размещены по стопкам, то  выводить ничего не нужно.
римечание: использовать STL.
Example:
input:
3
4 1 2 3 2
0
0
output:
1 2
1 3
1 2
Объяснение примера. Изначально в первой стопке лежат четыре контейнера – снизу контейнер с товаром первого вида, 
над ним – с товаром второго вида, над ним третьего, и сверху еще один контейнер с товаром второго вида. Вторая и третья стопки – пусты.
*/

/*
Задача 12.
tags: C++, сложность D, семестр 3, STL, работа с файлами
Для транспортирования материалов из цеха А в цех В используется конвейер. Материалы упаковываются в одинаковые контейнеры и размещаются на
ленте один за одним в порядке изготовления в цехе А. Каждый контейнер имеет степень срочности обработки в цехе В. Для упорядочивания 
контейнеров по степени срочности используют накопитель, который находится в конце конвейера перед входом в цех В. Накопитель работает пошагово, 
на каждом шаге возможны следующие действия:
* накопитель перемещает первый контейнер из ленты в цех В;
* накопитель перемещает первый контейнер из строки в склад (в складе каждый следующий контейнер помещается на предыдущий);
* накопитель перемещает верхний контейнер из склада в цех В.
Напишите программу, которая по последовательности контейнеров определит, можно ли упорядочить их по степени срочности пользуясь описанным накопителем.
Входной файл в первой строке содержит количество тестов N. Далее следует N строк, каждый из которых описывает отдельный тест и содержит целое 
число K (1 ≤ K ≤ 10000) — количество контейнеров в последовательности и K действительных чисел — степеней срочности контейнеров в порядке 
их поступления из цеха А (меньшим числам соответствует большая степень срочности).
Выходные данные
Каждая строка выходного файла должна содержать ответ для одного теста. Необходимо вывести 1, если необходимое упорядочивание возможно, или 0 в противном случае.
Example:
input:
2
2 2.9 2.1
3 5.6 9.0 2.0
output:
1
0
*/

/*
Задача 13.
tags: C++, сложность C, семестр 3, STL
На барже располагается K грузовых отсеков. В каждый отсек можно поместить некоторое количество бочек с одним из 10 000 видов топлива.
Причём извлечь бочку из отсека можно лишь в случае, если все бочки, помещённые в этот отсек после неё, уже были извлечены.
Таким образом в каждый момент времени в каждом непустом отсеке имеется ровно одна бочка, которую можно извлечь не трогая остальных. 
Будем называть такие бочки крайними.
Изначально баржа пуста. Затем она последовательно проплывает через N доков, причём в каждом доке на баржу либо погружается бочка
с некоторым видом топлива в некоторый отсек, либо выгружается крайняя бочка из некоторого отсека. Однако, если указанный отсек пуст,
либо если выгруженная бочка содержит не тот вид топлива, который ожидалось, следует зафиксировать ошибку. Если на баржу оказывается
погружено более P бочек или если после прохождения всех доков она не стала пуста, следует также зафиксировать ошибку.
От вас требуется либо указать максимальное количество бочек, которые одновременно пребывали на барже либо зафиксировать ошибку.
В первой строке три целых числа N, K и P (1 ≤ N, K, P ≤ 100 000). Далее следует N строк с описанием действия, выполняемого в очередном доке. Если в нём происходит погрузка, то строка имеет вид «+ A B», где A — номер отсека, в который помещается бочка, а B — номер вида топлива в ней. Если же док занимается разгрузкой, то строка имеет вид «- A B», где A — номер отсека, из которого извлекается бочка, а B — номер ожидаемого вида топлива.
Вывести либо одно число, равное искомому максимуму в случае безошибочного прохождения баржой маршрута, либо вывести слово «Error» в противном случае.
Example:
input:
6 1 2
+ 1 1
+ 1 2
- 1 2
- 1 1
+ 1 3
- 1 3
output:
2
*/

/*
Задача 14.
tags: C++, сложность C, семестр 3, работа с файлами
На секретную базу в Арктике поступила шифровка – последовательность из n десятичных цифр. Она содержит номер секретной базы в Антарктиде, 
который является последовательностью из k десятичных цифр. При этом для того, чтобы отличить его от ненужной Вам информации, он повторен 
в шифровке хотя бы два раза (возможно, эти два вхождения перекрываются).
Напишите программу, которая по шифровке и длине номера секретной базы определяет, содержит ли шифровка номер базы. Учтите, что у базы может
быть несколько номеров, и все они могут быть переданы в шифровке.
Первая строка входного файла INPUT.TXT содержит два целых числа: n (1 ≤ n ≤ 10^5) и k (1 ≤ k ≤ 5) – длину шифровки и длину номера секретной 
базы соответственно. Вторая строка содержит n цифр – шифровку. Помните, что цифры в шифровке не разделяются пробелами.
В выходной файл OUTPUT.TXT выведите «YES», если шифровка содержит номер секретной базы, и «NO» в противном случае.
Example:
input:	
10 5
0123456789
output:
NO
input:
13 2
0123400056789
output:
YES
*/

/*
Задача 15.
tags: C++, сложность D, семестр 3, работа с файлами
В первой строке входного файла INPUT.TXT находится два числа N и M (1 ≤ N ≤ 103, 1 ≤ M ≤ 105). В следующих N строках находится по одному
слову из словаря. Все слова состоят из строчных английских букв. Длина каждого слова не превышает 20. Каждое слово состоит хотя бы из 
одного символа. Лишних пробелов перед словом и после него нет.
В следующих M строках находится текст сочинения. Текст состоит из заглавных и строчных английских букв, пробелов и знаков препинания: 
точек (.), запятых (,), двоеточий (:), точек с запятыми (;), тире (-), апострофов ('), кавычек ("), восклицательных (!) и вопросительных (?) знаков.
Общая длина текста не превосходит 104 символов. В данной задаче большие и маленькие буквы в словах не различаются.
В выходной файл OUTPUT.TXT выведите «Everything is going to be OK.», если с сочинением все в порядке. Если не все слова из текста встречаются в 
словаре, выведите «Some words from the text are unknown.». Если же предыдущее неверно, но некоторые слова из словаря не встречаются в тексте, 
выведите «The usage of the vocabulary is not perfect.».
Example:
№	INPUT.TXT	            OUTPUT.TXT
1	3 1
    am
    bill
    i
    I am Bill, am I?	    Everything is going to be OK.
2	2 2
    seven
    day
    On the
    seventh day	            Some words from the text are unknown.
3	4 1
    vocabulary
    wide
    too
    much
    Too wide vocabulary.	The usage of the vocabulary is not perfect.
*/